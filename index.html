<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procesador de Ex√°menes V/F - Ministerio</title>
    <script src="https://unpkg.com/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Procesador de Ex√°menes V/F - DPSP</h1>
            <p>Sistema de detecci√≥n precisa para ex√°menes de 180 preguntas con formato de 5 columnas</p>
            <p style="font-size: 1em; opacity: 0.8; margin-top: 10px;">
                üÜï <strong>Mejorado:</strong> Filtros de sobre exposici√≥n y realce de contraste para mejor detecci√≥n de marcas
            </p>
            <div style="margin-top: 20px;">
                <button class="btn" onclick="downloadTemplate()" style="background: linear-gradient(135deg, #28a745 0%, #34ce57 100%); border: none; color: white; font-weight: bold; padding: 10px 20px; border-radius: 8px; font-size: 1em; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
                    üìÑ Descargar Plantilla (PDF)
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <!-- zona de arrastre con icono y texto -->
                    <div class="upload-icon">üì§</div>
                    <div class="upload-text">Arrastra o haz click para cargar</div>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
            </div>

            <div class="preview-section" id="previewSection" style="display: none;">
                <h3>Vista previa del examen:</h3>
                <img id="imagePreview" class="image-preview" />
                <div class="preview-container">
                </div>
            </div>

            <div class="controls" id="controlsSection" style="display: none;">
                <button class="btn" id="processBtn" onclick="processExam()">
                    üîç Procesar Examen
                </button>
                <button class="btn secondary" id="calibrateBtn" onclick="calibrateDetection()" style="display: none;">
                    ‚öôÔ∏è Calibrar Detecci√≥n
                </button>
                <button class="btn" id="downloadBtn" onclick="downloadResults()" style="display: none;">
                    üìä Descargar CSV
                </button>
            </div>

            <div class="loading" id="loadingSection">
                <div class="spinner"></div>
                <h3 id="loadingText">Procesando examen...</h3>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p id="progressText">0%</p>
            </div>

            <div class="detection-info" id="detectionInfo" style="display: none;">
                <h3>üìä Informaci√≥n de Detecci√≥n</h3>
                <div class="detection-stats" id="detectionStats"></div>
                <div id="validationStatus"></div>
            </div>

            <div class="calibration-workspace" id="calibrationWorkspace" style="display: none;">
                <div class="calibration-columns">
                    <!-- Panel de Calibraci√≥n -->
                    <div class="calibration-panel">
                        <h3>‚öôÔ∏è Panel de Calibraci√≥n</h3>
                        <div class="calibration-controls">
                            <div class="control-group">
                                <label for="marginLeftSlider">Margen Izquierdo:</label>
                                <input type="range" id="marginLeftSlider" min="0" max="0.3" step="0.001" value="0.1">
                                <span id="marginLeftDisplay">0.1000</span>
                            </div>

                            <div class="control-group">
                                <label for="marginTopSlider">Margen Superior:</label>
                                <input type="range" id="marginTopSlider" min="0" max="0.3" step="0.001" value="0.15">
                                <span id="marginTopDisplay">0.1500</span>
                            </div>

                            <div class="control-group">
                                <label for="colSpacingSlider">Espaciado Columnas:</label>
                                <input type="range" id="colSpacingSlider" min="0.15" max="0.25" step="0.001"
                                    value="0.196">
                                <span id="colSpacingDisplay">0.1960</span>
                            </div>

                            <div class="control-group">
                                <label for="rowSpacingSlider">Espaciado Filas:</label>
                                <input type="range" id="rowSpacingSlider" min="0.015" max="0.03" step="0.0001"
                                    value="0.0205">
                                <span id="rowSpacingDisplay">0.0205</span>
                            </div>

                            <div class="control-group">
                                <label for="circleOffsetXSlider">Offset C√≠rculo V:</label>
                                <input type="range" id="circleOffsetXSlider" min="0.02" max="0.08" step="0.001"
                                    value="0.045">
                                <span id="circleOffsetXDisplay">0.0450</span>
                            </div>

                            <div class="control-group">
                                <label for="circleOffsetXBetweenSlider">Distancia V-F:</label>
                                <input type="range" id="circleOffsetXBetweenSlider" min="0.01" max="0.05" step="0.001"
                                    value="0.025">
                                <span id="circleOffsetXBetweenDisplay">0.0250</span>
                            </div>

                            <div class="control-group">
                                <label for="radiusSlider">Radio Detecci√≥n:</label>
                                <input type="range" id="radiusSlider" min="0.003" max="0.015" step="0.0001"
                                    value="0.008">
                                <span id="radiusDisplay">0.0080</span>
                            </div>

                            <div class="control-group">
                                <label for="contrastSlider">Intensidad Contraste:</label>
                                <input type="range" id="contrastSlider" min="1.0" max="4.0" step="0.1" value="2.5">
                                <span id="contrastDisplay">2.5</span>
                            </div>

                            <div class="control-group">
                                <label for="exposureSlider">Sobre Exposici√≥n:</label>
                                <input type="range" id="exposureSlider" min="0.1" max="0.7" step="0.05" value="0.3">
                                <span id="exposureDisplay">0.3</span>
                            </div>

                            <div class="control-group">
                                <label for="thresholdSlider">Umbral Detecci√≥n:</label>
                                <input type="range" id="thresholdSlider" min="0.05" max="0.4" step="0.01" value="0.15">
                                <span id="thresholdDisplay">0.15</span>
                            </div>
                        </div>

                        <div class="calibration-actions">
                            <button class="btn" onclick="applyCalibration()">üéØ Aplicar Cambios</button>
                            <button class="btn secondary" onclick="resetCalibration()">üîÑ Restablecer</button>
                            <button class="btn" onclick="saveCalibration()">üíæ Guardar Config</button>
                        </div>

                        <div class="calibration-info">
                            <h4>üéØ Gu√≠a de Calibraci√≥n:</h4>
                            <ol>
                                <li>Ajusta el <strong>margen izquierdo</strong> hasta que los marcadores se alineen con
                                    la primera columna</li>
                                <li>Modifica el <strong>espaciado de columnas</strong> para que cubran todas las 5
                                    columnas</li>
                                <li>Ajusta el <strong>offset del c√≠rculo V</strong> para alinear con los c√≠rculos de
                                    Verdadero</li>
                                <li>Modifica la <strong>distancia V-F</strong> para alinear con los c√≠rculos de Falso
                                </li>
                                <li>Ajusta el <strong>radio de detecci√≥n</strong> seg√∫n el tama√±o de los c√≠rculos</li>
                                <li>üÜï <strong>Intensidad Contraste:</strong> Aumenta para mayor diferenciaci√≥n (2.0-4.0)</li>
                                <li>üÜï <strong>Sobre Exposici√≥n:</strong> Reduce para marcas m√°s oscuras (0.1-0.7)</li>
                                <li>üÜï <strong>Umbral Detecci√≥n:</strong> Ajusta sensibilidad de marcas (0.05-0.4)</li>
                            </ol>
                        </div>
                    </div>

                    <!-- Canvas de Vista Previa -->
                    <div class="canvas-preview">
                        <h3>üéØ Vista Previa - Calibraci√≥n en Tiempo Real</h3>
                        <canvas id="processingCanvas"></canvas>
                        <div class="canvas-controls">
                            <div class="canvas-info">
                                <strong>Leyenda:</strong>
                                üü¢ V marcado | üî¥ F marcado | ‚ö´ Vac√≠o | üü† Error
                            </div>
                            <div class="canvas-info">
                                <strong>Interacci√≥n:</strong> Haz clic en cualquier punto para ver coordenadas y
                                pregunta cercana
                            </div>
                            <div class="canvas-info">
                                <strong>Zoom:</strong> Usa Ctrl+Scroll para hacer zoom en la imagen
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="results-section" id="resultsSection">
                <h3>üìã Resultados por Columna</h3>
                <div class="results-grid" id="resultsGrid"></div>
            </div>

            <div id="debugInfo" class="debug-info" style="display: none;"></div>
        </div>
        
        <!-- Pie de p√°gina -->
        <footer class="footer">
            <div class="footer-content">
                <p>Procesador de MIPS ¬© <span id="currentYear"></span> | Todos los derechos reservados <small class="signature">Liao Miguel</small></p>
            </div>
        </footer>
    </div>

    <script>
        // Configuraci√≥n espec√≠fica para formato MIPS (5 columnas, 36 preguntas c/u)
        // Valores calibrados - Aplicados desde panel de calibraci√≥n
        const gridConfig = {
            marginLeft: 0.133,
            marginTop: 0.117,
            marginBottom: 0.12,
            colSpacing: 0.172,
            rowSpacing: 0.0217,
            circleOffsetX: 0.026,
            circleOffsetXBetween: 0.026,
            radius: 0.0095,
            numberWidth: 0.035,
            questionsPerColumn: 36,
            totalColumns: 5,
            totalQuestions: 180,
            // Nuevos par√°metros para filtros de imagen
            contrastFactor: 2.5,
            exposureFactor: 0.7,
            detectionThreshold: 0.15
        };

        let processedResults = [];
        let currentImageData = null;
        let detectionResults = null;

        // Establecer el a√±o actual en el footer
        document.addEventListener('DOMContentLoaded', function() {
            const currentYear = new Date().getFullYear();
            const yearElement = document.getElementById('currentYear');
            if (yearElement) {
                yearElement.textContent = currentYear;
            }
        });

        // Configurar drag and drop
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Agregar click al √°rea de carga para abrir selector de archivos
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showError('Por favor selecciona un archivo de imagen v√°lido (JPG, PNG, etc.).');
                return;
            }

            // Validar tama√±o de archivo (m√°ximo 10MB)
            if (file.size > 10 * 1024 * 1024) {
                showError('El archivo es muy grande. Por favor usa una imagen menor a 10MB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                currentImageData = e.target.result;
                showImagePreview(e.target.result);
                showSuccess('‚úÖ Imagen cargada correctamente. Lista para procesar formato MIPS (180 preguntas).');
            };
            reader.readAsDataURL(file);
        }

        function showImagePreview(src) {
            const previewSection = document.getElementById('previewSection');
            const imagePreview = document.getElementById('imagePreview');
            const controlsSection = document.getElementById('controlsSection');

            imagePreview.src = src;
            previewSection.style.display = 'block';
            controlsSection.style.display = 'flex';
        }

        async function processExam() {
            if (!currentImageData) {
                showError('No hay imagen cargada para procesar.');
                return;
            }

            showLoading(true);
            updateProgress(10, 'Iniciando procesamiento...');

            try {
                addDebugInfo('=== INICIO PROCESAMIENTO EXAMEN MINISTERIO ===');

                // Paso 1: An√°lisis de estructura del examen
                updateProgress(20, 'Analizando estructura del examen...');
                const structureAnalysis = await analyzeExamStructure(currentImageData);
                addDebugInfo(`‚úì Estructura analizada: ${structureAnalysis.columns} columnas detectadas`);

                // Paso 2: Detecci√≥n de n√∫meros de preguntas
                updateProgress(40, 'Detectando n√∫meros de preguntas...');
                const questionNumbers = await detectQuestionNumbers(currentImageData, structureAnalysis);
                addDebugInfo(`‚úì N√∫meros detectados: ${questionNumbers.length} preguntas encontradas`);

                // Paso 3: An√°lisis de c√≠rculos marcados
                updateProgress(60, 'Analizando c√≠rculos marcados...');
                const circleResults = await analyzeAnswerCircles(currentImageData, questionNumbers, structureAnalysis);
                addDebugInfo(`‚úì C√≠rculos analizados: ${circleResults.markedCount} marcados, ${circleResults.emptyCount} vac√≠os`);

                // Paso 4: Correlaci√≥n y ordenamiento
                updateProgress(80, 'Correlacionando respuestas...');
                const finalResults = await correlateAndOrder(questionNumbers, circleResults, structureAnalysis);
                addDebugInfo(`‚úì Correlaci√≥n completada: ${finalResults.validAnswers}/180 respuestas v√°lidas`);

                // Paso 5: Validaci√≥n final
                updateProgress(95, 'Validando resultados...');
                const validation = validateResults(finalResults);

                updateProgress(100, 'Procesamiento completado');
                showLoading(false);

                // Mostrar resultados
                processedResults = finalResults.answers;
                detectionResults = {
                    structure: structureAnalysis,
                    validation: validation,
                    stats: finalResults.stats
                };

                displayDetectionInfo();
                displayResults();

                if (validation.isValid) {
                    showSuccess(`üéØ ¬°Procesamiento exitoso! Detecci√≥n exacta lograda: ${finalResults.stats.valid}/180 respuestas detectadas.`);
                } else {
                    showWarning(`‚ö†Ô∏è ${validation.message}`);
                }

            } catch (error) {
                addDebugInfo(`‚ùå ERROR: ${error.message}`);
                console.error('Error completo:', error);
                showLoading(false);
                showError(`Error en el procesamiento: ${error.message}`);
            }
        }

        async function analyzeExamStructure(imageData) {
            return new Promise((resolve, reject) => {
                try {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        // An√°lisis espec√≠fico para formato ministerio con membrete y pie de p√°gina
                        const imageHeight = img.height;
                        const imageWidth = img.width;

                        // Estimar √°rea √∫til (excluyendo membrete y pie de p√°gina)
                        const headerHeight = Math.round(imageHeight * 0.15); // 15% superior para membrete
                        const footerHeight = Math.round(imageHeight * 0.10); // 10% inferior para pie de p√°gina
                        const usableHeight = imageHeight - headerHeight - footerHeight;
                        const usableY = headerHeight;

                        // M√°rgenes laterales
                        const sideMargin = Math.round(imageWidth * 0.05); // 5% en cada lado
                        const usableWidth = imageWidth - (sideMargin * 2);
                        const usableX = sideMargin;

                        addDebugInfo(`√Årea √∫til: ${usableWidth}x${usableHeight} desde (${usableX}, ${usableY})`);

                        resolve({
                            totalWidth: imageWidth,
                            totalHeight: imageHeight,
                            usableArea: {
                                x: usableX,
                                y: usableY,
                                width: usableWidth,
                                height: usableHeight
                            },
                            columns: 5,
                            questionsPerColumn: 36,
                            columnWidth: usableWidth / 5,
                            rowHeight: usableHeight / 36
                        });
                    };
                    img.onerror = () => reject(new Error('Error cargando imagen para an√°lisis'));
                    img.src = imageData;
                } catch (error) {
                    reject(error);
                }
            });
        } async function detectQuestionNumbers(imageData, structure) {
            let worker = null;
            try {
                addDebugInfo('Iniciando detecci√≥n de n√∫meros con OCR...');
                worker = await Tesseract.createWorker();
                await worker.loadLanguage('eng');
                await worker.initialize('eng');

                // Configuraci√≥n m√°s permisiva para n√∫meros
                await worker.setParameters({
                    tessedit_char_whitelist: '0123456789',
                    tessedit_pageseg_mode: '6',
                    tessedit_ocr_engine_mode: '2',
                    preserve_interword_spaces: '1'
                });

                addDebugInfo('Ejecutando OCR para n√∫meros de preguntas...');
                const { data } = await worker.recognize(imageData);
                await worker.terminate();

                addDebugInfo(`OCR completado. Texto detectado: "${data.text.substring(0, 200)}..."`);
                addDebugInfo(`Preguntas encontradas: ${data.words ? data.words.length : 0}`);

                const detectedNumbers = [];

                if (data.words) {
                    data.words.forEach((word, index) => {
                        addDebugInfo(`Preguntas ${index}: "${word.text}" confianza: ${word.confidence}`);

                        const num = parseInt(word.text.trim());
                        if (num >= 1 && num <= 180 && word.bbox && word.confidence > 30) { // Reducido umbral
                            // Verificar que est√° en el √°rea √∫til
                            const centerX = word.bbox.x0 + (word.bbox.x1 - word.bbox.x0) / 2;
                            const centerY = word.bbox.y0 + (word.bbox.y1 - word.bbox.y0) / 2;

                            addDebugInfo(`N√∫mero ${num} encontrado en (${Math.round(centerX)}, ${Math.round(centerY)})`);

                            if (centerX >= structure.usableArea.x &&
                                centerX <= structure.usableArea.x + structure.usableArea.width &&
                                centerY >= structure.usableArea.y &&
                                centerY <= structure.usableArea.y + structure.usableArea.height) {

                                // Determinar columna
                                const relativeX = centerX - structure.usableArea.x;
                                const column = Math.floor(relativeX / structure.columnWidth);

                                // Determinar fila
                                const relativeY = centerY - structure.usableArea.y;
                                const row = Math.floor(relativeY / structure.rowHeight);

                                const numberData = {
                                    number: num,
                                    x: centerX,
                                    y: centerY,
                                    column: Math.min(column, 4), // 0-4
                                    row: Math.min(row, 35), // 0-35
                                    confidence: word.confidence,
                                    bbox: word.bbox
                                };

                                detectedNumbers.push(numberData);
                                addDebugInfo(`‚úì N√∫mero ${num} v√°lido en columna ${column + 1}, fila ${row + 1}`);
                            } else {
                                addDebugInfo(`‚úó N√∫mero ${num} fuera del √°rea √∫til`);
                            }
                        }
                    });
                }

                // Si no se detectaron n√∫meros, intentar m√©todo alternativo
                if (detectedNumbers.length === 0) {
                    addDebugInfo('No se detectaron n√∫meros con OCR, intentando detecci√≥n de patrones...');
                    return await detectNumbersAlternative(imageData, structure);
                }

                // Eliminar duplicados y ordenar
                const uniqueNumbers = [];
                detectedNumbers.forEach(num => {
                    const existing = uniqueNumbers.find(u => u.number === num.number);
                    if (!existing) {
                        uniqueNumbers.push(num);
                    } else if (num.confidence > existing.confidence) {
                        const index = uniqueNumbers.indexOf(existing);
                        uniqueNumbers[index] = num;
                    }
                });

                uniqueNumbers.sort((a, b) => a.number - b.number);
                addDebugInfo(`OCR detect√≥ ${uniqueNumbers.length} n√∫meros √∫nicos v√°lidos`);

                if (uniqueNumbers.length > 0) {
                    const samples = uniqueNumbers.slice(0, 5).map(n => `${n.number}(col${n.column + 1})`).join(', ');
                    addDebugInfo(`Muestra: ${samples}`);
                }

                return uniqueNumbers;

            } catch (error) {
                if (worker) await worker.terminate();
                addDebugInfo(`Error en OCR: ${error.message}`);

                // Usar m√©todo alternativo en caso de error
                addDebugInfo('Usando m√©todo alternativo de detecci√≥n...');
                return await detectNumbersAlternative(imageData, structure);
            }
        }

        async function detectNumbersAlternative(imageData, structure) {
            addDebugInfo('Iniciando detecci√≥n alternativa basada en grid...');

            // Generar posiciones estimadas basadas en el grid conocido
            const estimatedNumbers = [];

            for (let col = 0; col < 5; col++) {
                for (let row = 0; row < 36; row++) {
                    const questionNum = col * 36 + row + 1;

                    // Posici√≥n estimada del n√∫mero en el grid
                    const x = structure.usableArea.x + (col * structure.columnWidth) + (structure.columnWidth * 0.1);
                    const y = structure.usableArea.y + (row * structure.rowHeight) + (structure.rowHeight * 0.5);

                    estimatedNumbers.push({
                        number: questionNum,
                        x: x,
                        y: y,
                        column: col,
                        row: row,
                        confidence: 50,
                        isEstimated: true
                    });
                }
            }

            addDebugInfo(`Generadas ${estimatedNumbers.length} posiciones estimadas`);
            return estimatedNumbers;
        }

        function generateFallbackNumbers(structure) {
            const fallbackNumbers = [];
            for (let col = 0; col < 5; col++) {
                for (let row = 0; row < 36; row++) {
                    const questionNum = col * 36 + row + 1;
                    const x = structure.usableArea.x + (col * structure.columnWidth) + (structure.columnWidth * 0.1);
                    const y = structure.usableArea.y + (row * structure.rowHeight) + (structure.rowHeight * 0.5);

                    fallbackNumbers.push({
                        number: questionNum,
                        x: x,
                        y: y,
                        column: col,
                        row: row,
                        confidence: 60,
                        isFallback: true
                    });
                }
            }
            addDebugInfo('Usando n√∫meros secuenciales como fallback');
            return fallbackNumbers;
        } async function analyzeAnswerCircles(imageData, questionNumbers, structure) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    addDebugInfo('=== INICIO AN√ÅLISIS DE C√çRCULOS ===');

                    const canvas = document.getElementById('processingCanvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    // ‚ú® APLICAR FILTROS DE MEJORA DE IMAGEN ANTES DEL AN√ÅLISIS
                    addDebugInfo('üì∏ Aplicando filtros de mejora de imagen...');
                    addDebugInfo('   ‚Ä¢ Filtro de sobre exposici√≥n para resaltar marcas');
                    addDebugInfo('   ‚Ä¢ Mejora de contraste agresiva');
                    addDebugInfo('   ‚Ä¢ Realce espec√≠fico de marcas de grafito/tinta');
                    
                    const enhancedImageData = enhanceImageForMarking(imageData, canvas, ctx);
                    addDebugInfo('‚úÖ Filtros aplicados exitosamente');

                    // Mostrar workspace de calibraci√≥n para debug visual
                    const calibrationWorkspace = document.getElementById('calibrationWorkspace');
                    calibrationWorkspace.style.display = 'block';

                    // Actualizar valores de configuraci√≥n mostrados (si existen los elementos)
                    const marginLeftValue = document.getElementById('marginLeftValue');
                    const circleOffsetXValue = document.getElementById('circleOffsetXValue');
                    const radiusValue = document.getElementById('radiusValue');

                    if (marginLeftValue) marginLeftValue.textContent = gridConfig.marginLeft;
                    if (circleOffsetXValue) circleOffsetXValue.textContent = gridConfig.circleOffsetX;
                    if (radiusValue) radiusValue.textContent = gridConfig.radius;

                    // Informaci√≥n sobre el tama√±o
                    addDebugInfo(`Canvas visible: ${img.width}x${img.height} p√≠xeles, escalado para visualizaci√≥n`);

                    // A√±adir funcionalidad de clic para calibraci√≥n
                    canvas.onclick = function (event) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        const x = (event.clientX - rect.left) * scaleX;
                        const y = (event.clientY - rect.top) * scaleY;

                        addDebugInfo(`üéØ CLICK en coordenadas: (${Math.round(x)}, ${Math.round(y)})`);
                        addDebugInfo(`   Porcentajes: X=${(x / width * 100).toFixed(2)}%, Y=${(y / height * 100).toFixed(2)}%`);

                        // Encontrar la pregunta m√°s cercana
                        let closestQuestion = null;
                        let minDistance = Infinity;

                        circles.forEach(circle => {
                            const distV = Math.sqrt((x - circle.details.positions.V.x) ** 2 + (y - circle.details.positions.V.y) ** 2);
                            const distF = Math.sqrt((x - circle.details.positions.F.x) ** 2 + (y - circle.details.positions.F.y) ** 2);
                            const minDist = Math.min(distV, distF);

                            if (minDist < minDistance) {
                                minDistance = minDist;
                                closestQuestion = {
                                    ...circle,
                                    clickedCircle: distV < distF ? 'V' : 'F',
                                    distance: minDist
                                };
                            }
                        });

                        if (closestQuestion) {
                            addDebugInfo(`   Pregunta m√°s cercana: Q${closestQuestion.questionNumber} (Col${closestQuestion.column}, ${closestQuestion.clickedCircle})`);
                            addDebugInfo(`   Estado actual: ${closestQuestion.selected || 'vac√≠o'}, Confianza: ${(closestQuestion.confidence * 100).toFixed(1)}%`);
                        }
                    };

                    const { data, width, height } = enhancedImageData;
                    addDebugInfo(`üîç Imagen mejorada procesada: ${width}x${height} p√≠xeles con filtros aplicados`);

                    const circles = [];
                    let markedCount = 0;
                    let emptyCount = 0;
                    let bothMarkedCount = 0;

                    // An√°lisis m√°s detallado por cada pregunta
                    for (let i = 1; i <= 180; i++) {
                        const col = Math.floor((i - 1) / 36);
                        const row = (i - 1) % 36;

                        // Calcular posiciones usando EXACTAMENTE la misma l√≥gica que la calibraci√≥n
                        // USAR gridConfig para coordenadas consistentes
                        const xBase = (gridConfig.marginLeft * width) + (col * gridConfig.colSpacing * width);
                        const yRow = (gridConfig.marginTop * height) + (row * gridConfig.rowSpacing * height);

                        // Posiciones de los c√≠rculos V y F
                        const cxV = xBase + (gridConfig.circleOffsetX * width);
                        const cxF = cxV + (gridConfig.circleOffsetXBetween * width);
                        const cy = yRow;
                        const r = gridConfig.radius * width;

                        // Analizar c√≠rculo V
                        const resV = analyzeCircleRegion(data, width, height, cxV, cy, r);
                        // Analizar c√≠rculo F
                        const resF = analyzeCircleRegion(data, width, height, cxF, cy, r);

                        // Determinar cu√°l est√° marcado con l√≥gica m√°s robusta
                        let selected = '';
                        let confidence = 0;
                        let status = 'empty';

                        // Umbrales adaptativos mejorados para imagen con filtros
                        const minThreshold = gridConfig.detectionThreshold;    // Umbral configurable
                        const strongThreshold = gridConfig.detectionThreshold + 0.1; // Umbral fuerte

                        const vMarked = resV.darkRatio > minThreshold;
                        const fMarked = resF.darkRatio > minThreshold;

                        if (vMarked && fMarked) {
                            // Ambos marcados - elegir el m√°s marcado si hay diferencia significativa
                            if (Math.abs(resV.darkRatio - resF.darkRatio) > 0.1) {
                                if (resV.darkRatio > resF.darkRatio) {
                                    selected = 'V';
                                    confidence = resV.confidence;
                                    status = 'marked_v';
                                    markedCount++; // Solo el c√≠rculo seleccionado cuenta como marcado
                                    emptyCount++;  // El otro c√≠rculo cuenta como vac√≠o
                                } else {
                                    selected = 'F';
                                    confidence = resF.confidence;
                                    status = 'marked_f';
                                    markedCount++; // Solo el c√≠rculo seleccionado cuenta como marcado
                                    emptyCount++;  // El otro c√≠rculo cuenta como vac√≠o
                                }
                            } else {
                                selected = 'ERROR_BOTH';
                                confidence = Math.max(resV.confidence, resF.confidence);
                                status = 'error_both';
                                bothMarkedCount++;
                                markedCount += 2; // Ambos c√≠rculos cuentan como marcados en caso de error
                            }
                        } else if (vMarked && !fMarked) {
                            selected = 'V';
                            confidence = resV.confidence;
                            status = 'marked_v';
                            markedCount++; // C√≠rculo V marcado
                            emptyCount++;  // C√≠rculo F vac√≠o
                        } else if (fMarked && !vMarked) {
                            selected = 'F';
                            confidence = resF.confidence;
                            status = 'marked_f';
                            markedCount++; // C√≠rculo F marcado
                            emptyCount++;  // C√≠rculo V vac√≠o
                        } else {
                            // Ninguno marcado claramente (pregunta no respondida)
                            selected = '';
                            confidence = 0;
                            status = 'empty';
                            emptyCount += 2; // Ambos c√≠rculos vac√≠os
                        }

                        circles.push({
                            questionNumber: i,
                            column: col + 1,
                            row: row + 1,
                            selected: selected,
                            confidence: confidence,
                            status: status,
                            details: {
                                V: resV,
                                F: resF,
                                positions: {
                                    V: { x: Math.round(cxV), y: Math.round(cy) },
                                    F: { x: Math.round(cxF), y: Math.round(cy) }
                                }
                            }
                        });

                        // Debug detallado para las primeras preguntas
                        if (i <= 5 || (i % 36 === 1)) {
                            addDebugInfo(`Q${i} (Col${col + 1}): V=${resV.darkRatio.toFixed(3)} F=${resF.darkRatio.toFixed(3)} ‚Üí ${selected || 'vac√≠o'}`);
                        }
                    }

                    // Estad√≠sticas de detecci√≥n
                    const validAnswers = circles.filter(c => c.selected && c.selected !== 'ERROR_BOTH').length;
                    const errorAnswers = circles.filter(c => c.selected === 'ERROR_BOTH').length;

                    addDebugInfo(`=== ESTAD√çSTICAS DE DETECCI√ìN ===`);
                    addDebugInfo(`Total c√≠rculos analizados: ${circles.length * 2} (${circles.length} preguntas √ó 2 c√≠rculos)`);
                    addDebugInfo(`C√≠rculos marcados: ${markedCount}`);
                    addDebugInfo(`C√≠rculos vac√≠os: ${emptyCount}`);
                    addDebugInfo(`Respuestas v√°lidas: ${validAnswers}/180`);
                    addDebugInfo(`Respuestas con errores (ambos marcados): ${errorAnswers}`);
                    addDebugInfo(`Porcentaje de detecci√≥n: ${((validAnswers / 180) * 100).toFixed(1)}%`);

                    // Dibujar marcas visuales en el canvas para debug
                    drawDebugMarkers(ctx, circles, structure);

                    resolve({
                        circles,
                        markedCount,
                        emptyCount,
                        validAnswers,
                        errorAnswers,
                        totalCircles: circles.length * 2
                    });
                };
                img.src = imageData;
            });
        }
        function analyzeCircleRegion(pixels, width, height, centerX, centerY, radius) {
            // Validar par√°metros
            if (!pixels || width <= 0 || height <= 0 || radius <= 0) {
                return { isMarked: false, confidence: 0, darkRatio: 0, error: 'Par√°metros inv√°lidos' };
            }

            const startX = Math.max(0, Math.round(centerX - radius));
            const endX = Math.min(width - 1, Math.round(centerX + radius));
            const startY = Math.max(0, Math.round(centerY - radius));
            const endY = Math.min(height - 1, Math.round(centerY + radius));

            let darkPixels = 0;
            let totalPixels = 0;
            let pixelValues = [];
            let edgePixels = 0; // P√≠xeles en el borde del c√≠rculo
            let centerPixels = 0; // P√≠xeles en el centro del c√≠rculo

            // An√°lisis por anillos conc√©ntricos
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);

                    if (distance <= radius) {
                        const pixelIndex = (y * width + x) * 4;

                        // Verificar que no se sale de los l√≠mites del array
                        if (pixelIndex + 2 < pixels.length) {
                            const r = pixels[pixelIndex];
                            const g = pixels[pixelIndex + 1];
                            const b = pixels[pixelIndex + 2];

                            // Conversi√≥n a escala de grises m√°s precisa
                            const gray = 0.299 * r + 0.587 * g + 0.114 * b;

                            pixelValues.push(gray);
                            totalPixels++;

                            // Clasificar por posici√≥n en el c√≠rculo
                            if (distance <= radius * 0.6) {
                                centerPixels++;
                            } else if (distance >= radius * 0.8) {
                                edgePixels++;
                            }

                            // Umbral m√°s agresivo para p√≠xeles oscuros despu√©s de filtros
                            // Con los filtros aplicados, las marcas deber√≠an ser mucho m√°s oscuras
                            if (gray < 80) { // Umbral m√°s bajo debido a sobre exposici√≥n
                                darkPixels++;
                            }
                        }
                    }
                }
            }

            if (totalPixels === 0) {
                return {
                    isMarked: false,
                    confidence: 0,
                    darkRatio: 0,
                    error: 'No se encontraron p√≠xeles v√°lidos',
                    totalPixels: 0
                };
            }

            // C√°lculos estad√≠sticos
            const darkRatio = darkPixels / totalPixels;
            const avgGray = pixelValues.reduce((sum, val) => sum + val, 0) / pixelValues.length;
            const variance = pixelValues.reduce((sum, val) => sum + Math.pow(val - avgGray, 2), 0) / pixelValues.length;
            const stdDev = Math.sqrt(variance);

            // An√°lisis de distribuci√≥n de valores
            pixelValues.sort((a, b) => a - b);
            const median = pixelValues[Math.floor(pixelValues.length / 2)];
            const q1 = pixelValues[Math.floor(pixelValues.length * 0.25)];
            const q3 = pixelValues[Math.floor(pixelValues.length * 0.75)];

            // Detecci√≥n de marcado m√°s sofisticada
            let threshold = 0.25; // Umbral base
            let isMarked = false;
            let confidence = 0;

            // Criterios m√∫ltiples para detecci√≥n
            const criteriaResults = {
                darkRatio: darkRatio > threshold,
                avgGrayLow: avgGray < 100,
                medianLow: median < 90,
                varianceHigh: variance > 300, // Indica contraste
                q1Low: q1 < 70 // Primer cuartil muy oscuro
            };

            // Conteo de criterios que indican marcado
            const positiveResults = Object.values(criteriaResults).filter(Boolean).length;

            // Decisi√≥n basada en m√∫ltiples criterios
            if (positiveResults >= 3) {
                isMarked = true;
                confidence = 0.8 + (positiveResults * 0.05);
            } else if (positiveResults >= 2 && darkRatio > 0.2) {
                isMarked = true;
                confidence = 0.6 + (darkRatio * 0.5);
            } else if (darkRatio > 0.35) {
                // Muy alto ratio de p√≠xeles oscuros
                isMarked = true;
                confidence = darkRatio;
            } else {
                isMarked = false;
                confidence = 1 - darkRatio;
            }

            // Ajustar confianza basada en calidad de an√°lisis
            if (totalPixels < 10) {
                confidence *= 0.5; // Reducir confianza si hay muy pocos p√≠xeles
            }

            confidence = Math.min(0.99, Math.max(0.01, confidence));

            return {
                isMarked,
                confidence: Math.round(confidence * 100) / 100,
                darkRatio: Math.round(darkRatio * 1000) / 1000,
                avgGray: Math.round(avgGray),
                median: Math.round(median),
                variance: Math.round(variance),
                stdDev: Math.round(stdDev),
                q1: Math.round(q1),
                q3: Math.round(q3),
                threshold,
                totalPixels,
                centerPixels,
                edgePixels,
                criteria: criteriaResults,
                positiveResults
            };
        }

        async function correlateAndOrder(questionNumbers, circleResults, structure) {
            addDebugInfo('=== CORRELACI√ìN Y ORDENAMIENTO ===');

            // Ordenar resultados por n√∫mero de pregunta
            const sortedCircles = circleResults.circles.sort((a, b) => a.questionNumber - b.questionNumber);

            // Generar respuestas en formato CSV
            const answers = sortedCircles.map(circle => ({
                question: circle.questionNumber,
                verdadero: circle.selected === 'V' ? 'X' : '',
                falso: circle.selected === 'F' ? 'X' : '',
                confidence: circle.confidence || 0,
                status: circle.status || 'unknown',
                column: circle.column,
                row: circle.row
            }));

            // Estad√≠sticas detalladas
            const validAnswers = sortedCircles.filter(c => c.selected && c.selected !== 'ERROR_BOTH').length;
            const errorAnswers = sortedCircles.filter(c => c.selected === 'ERROR_BOTH').length;
            const emptyAnswers = sortedCircles.filter(c => !c.selected || c.selected === '').length;
            const vAnswers = sortedCircles.filter(c => c.selected === 'V').length;
            const fAnswers = sortedCircles.filter(c => c.selected === 'F').length;

            // An√°lisis por columnas
            const columnStats = [];
            for (let col = 1; col <= 5; col++) {
                const columnCircles = sortedCircles.filter(c => c.column === col);
                const columnValid = columnCircles.filter(c => c.selected && c.selected !== 'ERROR_BOTH').length;
                const columnEmpty = columnCircles.filter(c => !c.selected || c.selected === '').length;
                const columnErrors = columnCircles.filter(c => c.selected === 'ERROR_BOTH').length;

                columnStats.push({
                    column: col,
                    total: columnCircles.length,
                    valid: columnValid,
                    empty: columnEmpty,
                    errors: columnErrors,
                    percentage: Math.round((columnValid / 36) * 100)
                });
            }

            addDebugInfo(`Respuestas procesadas: ${answers.length}`);
            addDebugInfo(`V√°lidas: ${validAnswers}, Vac√≠as: ${emptyAnswers}, Errores: ${errorAnswers}`);
            addDebugInfo(`Verdadero: ${vAnswers}, Falso: ${fAnswers}`);

            // Log de estad√≠sticas por columna
            columnStats.forEach(stat => {
                addDebugInfo(`Columna ${stat.column}: ${stat.valid}/36 v√°lidas (${stat.percentage}%)`);
            });

            // Verificar si la l√≥gica de detecci√≥n es coherente
            // Para N preguntas respondidas: N c√≠rculos marcados + N vac√≠os
            // Para M preguntas no respondidas: 2M c√≠rculos vac√≠os
            // Total c√≠rculos: 360 (180 preguntas √ó 2 c√≠rculos cada una)
            const totalCircles = 360;
            const totalMarked = circleResults.markedCount;
            const totalEmpty = circleResults.emptyCount;
            const totalDetected = totalMarked + totalEmpty;

            // Calcular preguntas respondidas bas√°ndose en c√≠rculos marcados
            const answeredQuestions = totalMarked - (errorAnswers * 2) + errorAnswers; // Restar c√≠rculos extra de errores
            const unansweredQuestions = 180 - answeredQuestions;
            const expectedMarked = answeredQuestions;
            const expectedEmpty = answeredQuestions + (unansweredQuestions * 2);

            const detectionAccurate = (totalDetected === totalCircles &&
                totalMarked === expectedMarked &&
                totalEmpty === expectedEmpty);

            if (detectionAccurate) {
                addDebugInfo(`‚úÖ DETECCI√ìN COHERENTE: ${answeredQuestions} preguntas respondidas, ${unansweredQuestions} no respondidas`);
                addDebugInfo(`   C√≠rculos marcados: ${totalMarked}, C√≠rculos vac√≠os: ${totalEmpty}, Total: ${totalDetected}/360`);
            } else {
                addDebugInfo(`‚ö†Ô∏è DETECCI√ìN INEXACTA: Total c√≠rculos: ${totalDetected}/360`);
                addDebugInfo(`   Marcados: ${totalMarked} (esperado: ${expectedMarked}), Vac√≠os: ${totalEmpty} (esperado: ${expectedEmpty})`);
            }

            return {
                answers,
                validAnswers,
                stats: {
                    total: answers.length,
                    valid: validAnswers,
                    empty: emptyAnswers,
                    errors: errorAnswers,
                    vAnswers,
                    fAnswers,
                    detectionAccurate,
                    totalMarked: circleResults.markedCount,
                    totalEmpty: circleResults.emptyCount,
                    totalCircles: circleResults.totalCircles,
                    answeredQuestions: totalMarked - (errorAnswers * 2) + errorAnswers,
                    unansweredQuestions: 180 - (totalMarked - (errorAnswers * 2) + errorAnswers),
                    columnStats
                }
            };
        }

        function validateResults(results) {
            addDebugInfo('=== VALIDACI√ìN DE RESULTADOS ===');

            const stats = results.stats;
            const totalQuestions = 180;
            const validAnswers = stats.valid;
            const completionRate = (validAnswers / totalQuestions) * 100;

            let isValid = true;
            let message = '';
            let status = 'success';

            // Nueva l√≥gica de validaci√≥n basada en coherencia de c√≠rculos
            if (stats.detectionAccurate) {
                // El sistema detect√≥ un patr√≥n coherente de c√≠rculos
                if (completionRate >= 98) {
                    message = `üéØ PERFECTO: ${validAnswers}/180 respuestas detectadas (${completionRate.toFixed(1)}%). Sistema coherente: ${stats.answeredQuestions} preguntas respondidas, ${stats.unansweredQuestions} no respondidas.`;
                    status = 'success';
                } else if (completionRate >= 90) {
                    message = `‚úÖ EXCELENTE: ${validAnswers}/180 respuestas detectadas (${completionRate.toFixed(1)}%). Sistema coherente: ${stats.answeredQuestions} preguntas respondidas, ${stats.unansweredQuestions} no respondidas.`;
                    status = 'success';
                } else if (completionRate >= 70) {
                    message = `‚ö†Ô∏è BUENO: ${validAnswers}/180 respuestas detectadas (${completionRate.toFixed(1)}%). Sistema coherente pero baja completitud.`;
                    status = 'warning';
                } else {
                    message = `‚ö†Ô∏è REGULAR: ${validAnswers}/180 respuestas detectadas (${completionRate.toFixed(1)}%). Sistema coherente pero muy baja completitud.`;
                    status = 'warning';
                }
            } else {
                // Sistema incoherente - problemas de detecci√≥n
                isValid = false;
                message = `‚ùå ERROR: Sistema incoherente. C√≠rculos detectados: ${stats.totalMarked} marcados + ${stats.totalEmpty} vac√≠os = ${stats.totalMarked + stats.totalEmpty}/${stats.totalCircles}. Se requiere coherencia en el patr√≥n de marcado.`;
                status = 'error';
            }

            // Informaci√≥n adicional sobre errores
            if (stats.errors > 0) {
                message += ` Errores detectados: ${stats.errors} (ambos c√≠rculos marcados).`;
            }

            // An√°lisis por columnas
            const columnProblems = stats.columnStats.filter(col => col.percentage < 80);
            if (columnProblems.length > 0) {
                const problemColumns = columnProblems.map(col => `Col${col.column}(${col.percentage}%)`).join(', ');
                message += ` Columnas con problemas: ${problemColumns}.`;
                if (status === 'success') status = 'warning';
            }

            addDebugInfo(`Validaci√≥n completada: ${isValid ? 'V√ÅLIDO' : 'INV√ÅLIDO'}`);
            addDebugInfo(`Estado: ${status}`);
            addDebugInfo(`Mensaje: ${message}`);

            return {
                isValid,
                message,
                status,
                completionRate,
                detectionAccurate: stats.detectionAccurate,
                stats: stats
            };
        }

        function displayDetectionInfo() {
            const detectionInfo = document.getElementById('detectionInfo');
            const detectionStats = document.getElementById('detectionStats');
            const validationStatus = document.getElementById('validationStatus');

            const stats = detectionResults.stats;
            const validation = detectionResults.validation;

            detectionStats.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${stats.total}</div>
                    <div class="stat-label">Total Preguntas</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.valid}</div>
                    <div class="stat-label">Respuestas V√°lidas</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.answeredQuestions || 'N/A'}</div>
                    <div class="stat-label">Preguntas Respondidas</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.unansweredQuestions || 'N/A'}</div>
                    <div class="stat-label">Preguntas No Respondidas</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.totalMarked}</div>
                    <div class="stat-label">C√≠rculos Marcados</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.totalEmpty}</div>
                    <div class="stat-label">C√≠rculos Vac√≠os</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.totalMarked + stats.totalEmpty}</div>
                    <div class="stat-label">Total C√≠rculos / 360</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.vAnswers}</div>
                    <div class="stat-label">Verdadero (V)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.fAnswers}</div>
                    <div class="stat-label">Falso (F)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${stats.errors}</div>
                    <div class="stat-label">Errores</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${validation.completionRate.toFixed(1)}%</div>
                    <div class="stat-label">Completitud</div>
                </div>
            `;

            // Mostrar estad√≠sticas por columna
            const columnStatsHtml = stats.columnStats.map(col => `
                <div class="column-stat ${col.percentage < 80 ? 'warning' : col.percentage >= 95 ? 'excellent' : 'good'}">
                    <strong>Columna ${col.column}:</strong> ${col.valid}/36 (${col.percentage}%)
                    ${col.errors > 0 ? `<span class="error-count">${col.errors} errores</span>` : ''}
                </div>
            `).join('');

            validationStatus.innerHTML = `
                <div class="validation-status validation-${validation.status}">
                    ${validation.message}
                </div>
                <div class="column-stats-container">
                    <h4>Estad√≠sticas por Columna:</h4>
                    ${columnStatsHtml}
                </div>
                <div class="detection-accuracy">
                    <strong>Sistema Coherente:</strong> 
                    <span class="${validation.detectionAccurate ? 'success' : 'error'}">
                        ${validation.detectionAccurate ? '‚úÖ S√ç' : '‚ùå NO'}
                    </span>
                    ${validation.detectionAccurate ?
                    `<span class="accuracy-note">Patr√≥n de marcado coherente detectado: ${stats.answeredQuestions} preguntas respondidas (${stats.totalMarked} c√≠rculos marcados) + ${stats.unansweredQuestions} no respondidas (${stats.totalEmpty - stats.answeredQuestions} c√≠rculos vac√≠os adicionales)</span>` :
                    '<span class="accuracy-note">Se requiere ajustar la detecci√≥n para lograr un patr√≥n coherente de c√≠rculos marcados/vac√≠os</span>'
                }
                </div>
            `;

            detectionInfo.style.display = 'block';

            // Mostrar botones adicionales
            document.getElementById('calibrateBtn').style.display = 'inline-block';
            document.getElementById('downloadBtn').style.display = 'inline-block';
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            const resultsGrid = document.getElementById('resultsGrid');

            // Agrupar respuestas por columna
            const columnData = [[], [], [], [], []];
            processedResults.forEach(result => {
                const colIndex = result.column - 1;
                if (colIndex >= 0 && colIndex < 5) {
                    columnData[colIndex].push(result);
                }
            });

            // Generar HTML para cada columna
            resultsGrid.innerHTML = columnData.map((columnResults, index) => {
                // Contar respuestas bas√°ndose en el formato real de datos (verdadero/falso con 'X')
                const trueCount = columnResults.filter(r => r.verdadero === 'X').length;
                const falseCount = columnResults.filter(r => r.falso === 'X').length;
                const emptyCount = columnResults.filter(r => r.verdadero === '' && r.falso === '').length;

                const answersHtml = columnResults.map(result => {
                    let className = 'answer-item ';
                    let answerText = '?';

                    // Determinar respuesta bas√°ndose en el formato real de datos
                    if (result.verdadero === 'X') {
                        className += 'true';
                        answerText = 'V';
                    } else if (result.falso === 'X') {
                        className += 'false';
                        answerText = 'F';
                    } else {
                        className += 'empty';
                        answerText = '?';
                    }

                    const confidenceText = result.confidence > 0 ? `${(result.confidence * 100).toFixed(0)}%` : '-';

                    return `
                        <div class="${className}">
                            <span>P${result.question}: ${answerText}</span>
                            <span class="confidence-badge">${confidenceText}</span>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="column-results">
                        <div class="column-header">
                            Columna ${index + 1}
                            <br>
                            <small>V:${trueCount} F:${falseCount} ?:${emptyCount}</small>
                        </div>
                        <div class="answer-list">
                            ${answersHtml}
                        </div>
                    </div>
                `;
            }).join('');

            resultsSection.style.display = 'block';
        }

        function calibrateDetection() {
            if (!currentImageData) {
                showError('Primero debes cargar y procesar una imagen para usar la calibraci√≥n.');
                return;
            }

            // Mostrar el workspace de calibraci√≥n
            const calibrationWorkspace = document.getElementById('calibrationWorkspace');
            calibrationWorkspace.style.display = 'block';

            // Inicializar los sliders con los valores actuales
            initializeCalibrationSliders();

            // Mostrar la imagen en el canvas de calibraci√≥n
            displayImageForCalibration();

            showSuccess('üéØ Panel de calibraci√≥n activado. Ajusta los par√°metros y observa los cambios en tiempo real.');
        }

        function initializeCalibrationSliders() {
            // Solo actualizar los valores, los listeners ya est√°n configurados
            const sliders = [
                { id: 'marginLeftSlider', value: gridConfig.marginLeft, display: 'marginLeftDisplay' },
                { id: 'marginTopSlider', value: gridConfig.marginTop, display: 'marginTopDisplay' },
                { id: 'colSpacingSlider', value: gridConfig.colSpacing, display: 'colSpacingDisplay' },
                { id: 'rowSpacingSlider', value: gridConfig.rowSpacing, display: 'rowSpacingDisplay' },
                { id: 'circleOffsetXSlider', value: gridConfig.circleOffsetX, display: 'circleOffsetXDisplay' },
                { id: 'circleOffsetXBetweenSlider', value: gridConfig.circleOffsetXBetween, display: 'circleOffsetXBetweenDisplay' },
                { id: 'radiusSlider', value: gridConfig.radius, display: 'radiusDisplay' },
                { id: 'contrastSlider', value: gridConfig.contrastFactor, display: 'contrastDisplay' },
                { id: 'exposureSlider', value: gridConfig.exposureFactor, display: 'exposureDisplay' },
                { id: 'thresholdSlider', value: gridConfig.detectionThreshold, display: 'thresholdDisplay' }
            ];

            sliders.forEach(slider => {
                const sliderElement = document.getElementById(slider.id);
                const displayElement = document.getElementById(slider.display);

                if (sliderElement && displayElement) {
                    sliderElement.value = slider.value;
                    const decimals = slider.id.includes('threshold') || slider.id.includes('exposure') ? 2 : 
                                   slider.id.includes('contrast') ? 1 : 4;
                    displayElement.textContent = slider.value.toFixed(decimals);
                }
            });
        }

        // Inicializar los event listeners de los sliders inmediatamente
        document.addEventListener('DOMContentLoaded', function () {
            setupSliderListeners();
            
            // Actualizar a√±o actual en el pie de p√°gina
            updateCurrentYear();
        });

        // Funci√≥n para actualizar el a√±o actual
        function updateCurrentYear() {
            const currentYear = new Date().getFullYear();
            const yearElement = document.getElementById('currentYear');
            if (yearElement) {
                yearElement.textContent = currentYear;
            }
        }

        function setupSliderListeners() {
            const sliders = [
                { id: 'marginLeftSlider', display: 'marginLeftDisplay' },
                { id: 'marginTopSlider', display: 'marginTopDisplay' },
                { id: 'colSpacingSlider', display: 'colSpacingDisplay' },
                { id: 'rowSpacingSlider', display: 'rowSpacingDisplay' },
                { id: 'circleOffsetXSlider', display: 'circleOffsetXDisplay' },
                { id: 'circleOffsetXBetweenSlider', display: 'circleOffsetXBetweenDisplay' },
                { id: 'radiusSlider', display: 'radiusDisplay' },
                { id: 'contrastSlider', display: 'contrastDisplay' },
                { id: 'exposureSlider', display: 'exposureDisplay' },
                { id: 'thresholdSlider', display: 'thresholdDisplay' }
            ];

            sliders.forEach(slider => {
                const sliderElement = document.getElementById(slider.id);
                const displayElement = document.getElementById(slider.display);

                if (sliderElement && displayElement) {
                    // Event listener para actualizaci√≥n en tiempo real
                    sliderElement.addEventListener('input', function () {
                        const newValue = parseFloat(this.value);
                        const decimals = slider.id.includes('threshold') || slider.id.includes('exposure') ? 2 : 
                                       slider.id.includes('contrast') ? 1 : 4;
                        displayElement.textContent = newValue.toFixed(decimals);

                        // Actualizar gridConfig
                        updateTempGridConfig(slider.id, newValue);

                        // Redibujar canvas si est√° visible
                        if (currentImageData && document.getElementById('calibrationWorkspace').style.display !== 'none') {
                            redrawCalibrationCanvas();
                        }
                    });
                }
            });
        }

        function updateTempGridConfig(sliderId, value) {
            // Mapear los IDs de los sliders a las propiedades de gridConfig
            const mapping = {
                'marginLeftSlider': 'marginLeft',
                'marginTopSlider': 'marginTop',
                'colSpacingSlider': 'colSpacing',
                'rowSpacingSlider': 'rowSpacing',
                'circleOffsetXSlider': 'circleOffsetX',
                'circleOffsetXBetweenSlider': 'circleOffsetXBetween',
                'radiusSlider': 'radius',
                'contrastSlider': 'contrastFactor',
                'exposureSlider': 'exposureFactor',
                'thresholdSlider': 'detectionThreshold'
            };

            if (mapping[sliderId]) {
                gridConfig[mapping[sliderId]] = value;
            }
        }

        function displayImageForCalibration() {
            if (!currentImageData) return;

            const img = new Image();
            img.onload = () => {
                const canvas = document.getElementById('processingCanvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                // Dibujar la grilla de calibraci√≥n inicial
                redrawCalibrationCanvas();
            };
            img.src = currentImageData;
        }

        function redrawCalibrationCanvas() {
            if (!currentImageData) return;

            const canvas = document.getElementById('processingCanvas');
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;

            // Limpiar canvas y redibujar imagen
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, width, height);
                ctx.drawImage(img, 0, 0);

                // Simplificar estructura para coincidir con procesamiento
                const structure = {
                    totalWidth: width,
                    totalHeight: height
                };

                // Dibujar grilla de calibraci√≥n
                drawCalibrationGrid(ctx, structure);
            };
            img.src = currentImageData;
        }

        function drawCalibrationGrid(ctx, structure) {
            // Configuraci√≥n visual
            const showQuestionNumbers = false; // Solo n√∫meros de muestra para no saturar
            const showAllCircles = true;

            // MOSTRAR TODOS LOS 360 C√çRCULOS para calibraci√≥n precisa
            for (let i = 1; i <= 180; i++) {
                const col = Math.floor((i - 1) / 36);
                const row = (i - 1) % 36;

                // Calcular posiciones usando EXACTAMENTE la misma l√≥gica que el procesamiento
                // USAR gridConfig para coordenadas consistentes
                const xBase = (gridConfig.marginLeft * structure.totalWidth) + (col * gridConfig.colSpacing * structure.totalWidth);
                const yRow = (gridConfig.marginTop * structure.totalHeight) + (row * gridConfig.rowSpacing * structure.totalHeight);

                // Posiciones de los c√≠rculos V y F
                const cxV = xBase + (gridConfig.circleOffsetX * structure.totalWidth);
                const cxF = cxV + (gridConfig.circleOffsetXBetween * structure.totalWidth);
                const cy = yRow;
                const r = Math.max(gridConfig.radius * structure.totalWidth, 4); // Radio m√≠nimo m√°s peque√±o

                // Determinar opacidad y grosor seg√∫n importancia
                const isCorner = (i === 1 || i === 36 || i === 37 || i === 72 || i === 73 || i === 108 || i === 109 || i === 144 || i === 145 || i === 180);
                const isFirstInColumn = (i % 36 === 1);
                const isLastInColumn = (i % 36 === 0);
                const isImportant = isCorner || isFirstInColumn || isLastInColumn;

                const lineWidth = isImportant ? 2 : 1;
                const alpha = isImportant ? 0.8 : 0.4;

                // Dibujar c√≠rculo V
                ctx.beginPath();
                ctx.arc(cxV, cy, r, 0, 2 * Math.PI);
                ctx.strokeStyle = `rgba(46, 204, 113, ${alpha})`;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
                if (isImportant) {
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.2)';
                    ctx.fill();
                }

                // Dibujar c√≠rculo F
                ctx.beginPath();
                ctx.arc(cxF, cy, r, 0, 2 * Math.PI);
                ctx.strokeStyle = `rgba(231, 76, 60, ${alpha})`;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
                if (isImportant) {
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.2)';
                    ctx.fill();
                }

                // Dibujar etiquetas V y F solo para preguntas importantes
                if (isImportant) {
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('V', cxV, cy - r - 3);
                    ctx.fillText('F', cxF, cy - r - 3);
                }

                // Dibujar n√∫mero de pregunta solo para algunos casos
                if (isImportant || (i <= 10) || (i % 30 === 0)) {
                    ctx.fillStyle = '#3498db';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(i.toString(), xBase - 20, cy + 2);
                }
            }

            // Dibujar l√≠neas de referencia para las columnas usando gridConfig
            ctx.strokeStyle = 'rgba(52, 152, 219, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            for (let col = 0; col <= 5; col++) {
                const x = (gridConfig.marginLeft * structure.totalWidth) + (col * gridConfig.colSpacing * structure.totalWidth);
                ctx.beginPath();
                ctx.moveTo(x, gridConfig.marginTop * structure.totalHeight);
                ctx.lineTo(x, structure.totalHeight * (1 - gridConfig.marginBottom));
                ctx.stroke();
            }

            // Dibujar l√≠neas de referencia para las filas (cada 6 filas)
            for (let row = 0; row <= 36; row += 6) {
                const y = (gridConfig.marginTop * structure.totalHeight) + (row * gridConfig.rowSpacing * structure.totalHeight);
                ctx.beginPath();
                ctx.moveTo(gridConfig.marginLeft * structure.totalWidth, y);
                ctx.lineTo(structure.totalWidth * (1 - 0.05), y); // 5% margen derecho
                ctx.stroke();
            }

            // Restablecer l√≠nea continua
            ctx.setLineDash([]);

            // Informaci√≥n de debug en el canvas actualizada
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(10, 10, 350, 120);
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 350, 120);

            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('üéØ Calibraci√≥n Activa - 360 C√≠rculos', 20, 30);
            ctx.font = '11px Arial';
            ctx.fillText(`Margen Izq: ${gridConfig.marginLeft.toFixed(3)} | Margen Top: ${gridConfig.marginTop.toFixed(3)}`, 20, 50);
            ctx.fillText(`Col Spacing: ${gridConfig.colSpacing.toFixed(3)} | Row Spacing: ${gridConfig.rowSpacing.toFixed(4)}`, 20, 70);
            ctx.fillText(`Offset V: ${gridConfig.circleOffsetX.toFixed(3)} | Dist V-F: ${gridConfig.circleOffsetXBetween.toFixed(3)}`, 20, 90);
            ctx.fillText(`Radio: ${gridConfig.radius.toFixed(4)} | Total c√≠rculos mostrados: 360`, 20, 110);
            ctx.fillText(`üéõÔ∏è Filtros - Contraste: ${gridConfig.contrastFactor.toFixed(1)} | Exposici√≥n: ${gridConfig.exposureFactor.toFixed(2)} | Umbral: ${gridConfig.detectionThreshold.toFixed(2)}`, 20, 130);
        }

        function applyCalibration() {
            if (!currentImageData) {
                showError('No hay imagen cargada para aplicar la calibraci√≥n.');
                return;
            }

            // Los valores ya est√°n actualizados en gridConfig
            showSuccess('‚úÖ Calibraci√≥n aplicada. Los nuevos valores se usar√°n en el pr√≥ximo procesamiento.');

            // Opcional: reprocesar autom√°ticamente
            if (confirm('¬øDeseas reprocesar la imagen con la nueva configuraci√≥n?')) {
                processExam();
            }
        }

        function resetCalibration() {
            // Restablecer a los valores calibrados actuales (valores por defecto actualizados)
            const defaultConfig = {
                marginLeft: 0.133,
                marginTop: 0.117,
                marginBottom: 0.12,
                colSpacing: 0.172,
                rowSpacing: 0.0217,
                circleOffsetX: 0.024,
                circleOffsetXBetween: 0.028,
                radius: 0.0128,
                numberWidth: 0.035,
                questionsPerColumn: 36,
                totalColumns: 5,
                totalQuestions: 180,
                contrastFactor: 3.0,
                exposureFactor: 0.25,
                detectionThreshold: 0.15
            };

            // Actualizar gridConfig global
            Object.assign(gridConfig, defaultConfig);

            // Reinicializar sliders
            initializeCalibrationSliders();

            // Redibujar canvas
            redrawCalibrationCanvas();

            showSuccess('üîÑ Configuraci√≥n restablecida a valores calibrados por defecto.');
        }

        function saveCalibration() {
            const configText = `// Configuraci√≥n de calibraci√≥n generada el ${new Date().toLocaleString()}
const gridConfig = {
    marginLeft: ${gridConfig.marginLeft},
    marginTop: ${gridConfig.marginTop},
    marginBottom: ${gridConfig.marginBottom},
    colSpacing: ${gridConfig.colSpacing},
    rowSpacing: ${gridConfig.rowSpacing},
    circleOffsetX: ${gridConfig.circleOffsetX},
    circleOffsetXBetween: ${gridConfig.circleOffsetXBetween},
    radius: ${gridConfig.radius},
    numberWidth: ${gridConfig.numberWidth},
    questionsPerColumn: ${gridConfig.questionsPerColumn},
    totalColumns: ${gridConfig.totalColumns},
    totalQuestions: ${gridConfig.totalQuestions}
};`;

            const blob = new Blob([configText], { type: 'text/javascript' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `gridConfig_${new Date().toISOString().split('T')[0]}.js`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showSuccess('üíæ Configuraci√≥n guardada como archivo JavaScript.');
        }

        function downloadResults() {
            if (processedResults.length === 0) {
                showError('No hay resultados para descargar.');
                return;
            }

            const csv = generateCSV();
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', `examen_ministerio_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showSuccess('Archivo CSV descargado correctamente.');
        }

        function generateCSV() {
            let csv = 'Numero;Verdadero;Falso\n';
            processedResults.forEach(res => {
                csv += `${res.question};${res.verdadero};${res.falso}\n`;
            });
            return csv;
        }

        function showLoading(show) {
            document.getElementById('loadingSection').style.display = show ? 'block' : 'none';
        }

        function updateProgress(percent, text = '') {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = percent + '%';
            if (text) {
                document.getElementById('loadingText').textContent = text;
            }
        }

        function showError(message) {
            const existing = document.querySelector('.error');
            if (existing) existing.remove();

            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = '‚ùå ' + message;

            document.querySelector('.main-content').insertBefore(errorDiv, document.querySelector('.upload-section').nextSibling);

            setTimeout(() => errorDiv.remove(), 8000);
        }

        function showSuccess(message) {
            const existing = document.querySelector('.success');
            if (existing) existing.remove();

            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = '‚úÖ ' + message;

            document.querySelector('.main-content').insertBefore(successDiv, document.querySelector('.upload-section').nextSibling);

            setTimeout(() => successDiv.remove(), 5000);
        }

        function showWarning(message) {
            const existing = document.querySelector('.validation-warning');
            if (existing) existing.remove();

            const warningDiv = document.createElement('div');
            warningDiv.className = 'validation-status validation-warning';
            warningDiv.textContent = '‚ö†Ô∏è ' + message;

            document.querySelector('.main-content').insertBefore(warningDiv, document.querySelector('.upload-section').nextSibling);

            setTimeout(() => warningDiv.remove(), 8000);
        } function addDebugInfo(message) {
            const debugDiv = document.getElementById('debugInfo');
            const shouldShow = true; // Activado para debugging
            if (shouldShow) {
                debugDiv.innerHTML += new Date().toLocaleTimeString() + ' - ' + message + '<br>';
                debugDiv.scrollTop = debugDiv.scrollHeight;
                debugDiv.style.display = 'block';
            }

            console.log(message);
        }

        /**
         * Dibuja marcadores visuales en el canvas para debug
         */
        function drawDebugMarkers(ctx, circles, structure) {
            const showDebugMarkers = true; // Cambiar a false para ocultar marcadores

            if (!showDebugMarkers) return;

            addDebugInfo('Dibujando marcadores de debug en canvas grande...');

            circles.forEach(circle => {
                const { V, F } = circle.details.positions;
                const radius = gridConfig.radius * structure.totalWidth;

                // Radio m√°s grande para mejor visualizaci√≥n
                const visualRadius = Math.max(radius * 2, 15);

                // Color seg√∫n el estado
                let color = '#666'; // Gris medio para vac√≠o
                if (circle.selected === 'V') color = '#2ecc71'; // Verde para V
                else if (circle.selected === 'F') color = '#e74c3c'; // Rojo para F
                else if (circle.selected === 'ERROR_BOTH') color = '#f39c12'; // Naranja para error

                // Dibujar c√≠rculo V con borde m√°s grueso
                ctx.beginPath();
                ctx.arc(V.x, V.y, visualRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = circle.selected === 'V' ? color : '#ccc';
                ctx.lineWidth = circle.selected === 'V' ? 4 : 2;
                ctx.stroke();

                // Relleno semi-transparente si est√° marcado o vac√≠o
                if (circle.selected === 'V') {
                    ctx.fillStyle = color + '40'; // 40 = 25% opacidad
                    ctx.fill();
                } else if (!circle.selected || circle.selected === '') {
                    // C√≠rculo vac√≠o con relleno gris claro
                    ctx.fillStyle = '#666' + '20'; // Gris medio con 12% opacidad
                    ctx.fill();
                }

                // Dibujar c√≠rculo F con borde m√°s grueso
                ctx.beginPath();
                ctx.arc(F.x, F.y, visualRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = circle.selected === 'F' ? color : '#ccc';
                ctx.lineWidth = circle.selected === 'F' ? 4 : 2;
                ctx.stroke();

                // Relleno semi-transparente si est√° marcado o vac√≠o
                if (circle.selected === 'F') {
                    ctx.fillStyle = color + '40'; // 40 = 25% opacidad
                    ctx.fill();
                } else if (!circle.selected || circle.selected === '') {
                    // C√≠rculo vac√≠o con relleno gris claro
                    ctx.fillStyle = '#666' + '20'; // Gris medio con 12% opacidad
                    ctx.fill();
                }

                // Dibujar n√∫mero de pregunta para mejor referencia
                if (circle.row <= 3 || circle.row >= 34 || circle.questionNumber % 10 === 1) {
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 14px Arial';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;

                    // Contorno blanco para mejor legibilidad
                    ctx.strokeText(`${circle.questionNumber}`, V.x - 25, V.y - 25);
                    ctx.fillText(`${circle.questionNumber}`, V.x - 25, V.y - 25);
                }

                // Mostrar letras V y F cerca de los c√≠rculos
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 12px Arial';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;

                // V
                ctx.strokeText('V', V.x - 5, V.y + 5);
                ctx.fillText('V', V.x - 5, V.y + 5);

                // F
                ctx.strokeText('F', F.x - 5, F.y + 5);
                ctx.fillText('F', F.x - 5, F.y + 5);
            });

            // Dibujar leyenda m√°s grande y detallada
            const legendWidth = 300;
            const legendHeight = 160;
            const legendX = 20;
            const legendY = 20;

            // Fondo de la leyenda
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.strokeRect(legendX, legendY, legendWidth, legendHeight);

            // T√≠tulo de la leyenda
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('üéØ Leyenda de Detecci√≥n:', legendX + 10, legendY + 25);

            // Elementos de la leyenda
            const legendItems = [
                { color: '#2ecc71', text: 'V marcado', y: 50 },
                { color: '#e74c3c', text: 'F marcado', y: 75 },
                { color: '#666', text: 'Vac√≠o', y: 100 },
                { color: '#f39c12', text: 'Error (ambos marcados)', y: 125 }
            ];

            legendItems.forEach(item => {
                // C√≠rculo de ejemplo
                ctx.beginPath();
                ctx.arc(legendX + 25, legendY + item.y, 8, 0, 2 * Math.PI);
                ctx.strokeStyle = item.color;
                ctx.lineWidth = item.color === '#666' ? 2 : 4;
                ctx.stroke();

                // Relleno seg√∫n el tipo
                if (item.color === '#666') {
                    // C√≠rculo vac√≠o con relleno gris claro
                    ctx.fillStyle = item.color + '30'; // Gris medio con m√°s opacidad para la leyenda
                    ctx.fill();
                } else if (item.color !== '#ddd') {
                    ctx.fillStyle = item.color + '40';
                    ctx.fill();
                }

                // Texto
                ctx.fillStyle = '#2c3e50';
                ctx.font = '12px Arial';
                ctx.fillText(item.text, legendX + 45, legendY + item.y + 5);
            });

            // Informaci√≥n adicional
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.fillText(`Total preguntas: ${circles.length} | Zoom: Ctrl+Scroll`, legendX + 10, legendY + legendHeight - 10);
        }

        // Funci√≥n para descargar la plantilla PDF
        function downloadTemplate() {
            const link = document.createElement('a');
            link.href = 'Plantilla.pdf';
            link.download = 'Plantilla_Examen_MIPS_180_Preguntas.pdf';
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showSuccess('üìÑ Plantilla descargada correctamente. Impr√≠mela para completar tu examen.');
        }

        // Funciones de preprocesamiento de imagen para mejorar detecci√≥n
        function enhanceImageForMarking(imageData, canvas, ctx) {
            const width = canvas.width;
            const height = canvas.height;
            const data = ctx.getImageData(0, 0, width, height);
            const pixels = data.data;
            
            // Aplicar m√∫ltiples filtros para mejorar las marcas
            applyOverexposureFilter(pixels, width, height);
            applyContrastEnhancement(pixels, width, height);
            applyMarkHighlighting(pixels, width, height);
            
            ctx.putImageData(data, 0, 0);
            return data;
        }

        function applyOverexposureFilter(pixels, width, height) {
            // Filtro de sobre exposici√≥n para resaltar marcas oscuras
            const exposureFactor = gridConfig.exposureFactor;
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                // Convertir a escala de grises
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                
                // Aplicar sobre exposici√≥n configurable
                let enhanced = gray;
                
                // Si es oscuro (posible marca), hacerlo M√ÅS oscuro
                if (gray < 150) {
                    enhanced = Math.max(0, gray * exposureFactor); // Oscurecer marcas
                } else {
                    // Si es claro, hacerlo M√ÅS claro
                    enhanced = Math.min(255, gray * 1.4 + 50); // Aclarar fondo
                }
                
                pixels[i] = enhanced;     // R
                pixels[i + 1] = enhanced; // G
                pixels[i + 2] = enhanced; // B
            }
        }

        function applyContrastEnhancement(pixels, width, height) {
            // Mejora de contraste para aumentar la diferencia entre marcas y fondo
            const factor = gridConfig.contrastFactor; // Factor de contraste configurable
            const intercept = 128 * (1 - factor);
            
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                // Aplicar contraste a cada canal
                pixels[i] = Math.max(0, Math.min(255, factor * r + intercept));
                pixels[i + 1] = Math.max(0, Math.min(255, factor * g + intercept));
                pixels[i + 2] = Math.max(0, Math.min(255, factor * b + intercept));
            }
        }

        function applyMarkHighlighting(pixels, width, height) {
            // Filtro espec√≠fico para destacar marcas de l√°piz/bol√≠grafo
            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                
                // Detectar tonos t√≠picos de grafito/tinta
                let enhanced = gray;
                
                if (gray < 180) {
                    // Zona potencial de marca - aplicar filtro de realce
                    const darkness = (180 - gray) / 180;
                    enhanced = gray * (1 - darkness * 0.8); // Oscurecer proporcionalmente
                    
                    // Si es muy oscuro, asegurar que sea completamente negro
                    if (gray < 100) {
                        enhanced = Math.min(enhanced, 30);
                    }
                }
                
                pixels[i] = enhanced;
                pixels[i + 1] = enhanced;
                pixels[i + 2] = enhanced;
            }
        }

        function applyAdaptiveThresholding(pixels, width, height) {
            // Umbralizaci√≥n adaptativa para mejorar la separaci√≥n de marcas
            const tempPixels = new Uint8ClampedArray(pixels);
            const windowSize = 15;
            const C = 10; // Constante de ajuste
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Calcular promedio local
                    let sum = 0;
                    let count = 0;
                    
                    for (let dy = -windowSize; dy <= windowSize; dy++) {
                        for (let dx = -windowSize; dx <= windowSize; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                const nIdx = (ny * width + nx) * 4;
                                sum += tempPixels[nIdx];
                                count++;
                            }
                        }
                    }
                    
                    const localMean = sum / count;
                    const threshold = localMean - C;
                    
                    const currentValue = tempPixels[idx];
                    const newValue = currentValue < threshold ? 0 : 255;
                    
                    pixels[idx] = newValue;
                    pixels[idx + 1] = newValue;
                    pixels[idx + 2] = newValue;
                }
            }
        }
    </script>
</body>

</html>